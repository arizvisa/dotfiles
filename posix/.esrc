let (cd = $fn-cd) fn cd {
    $cd $*;
    let (w = `pwd) {
        if {~ $w $home^*} {
            w = '~'^<={~~ $w $home^*}
        }
        let (bel = \007; ht = \011; lf = \012; vt = \013; ff = \014; cr = \015; esc = \033) {
            prompt = $esc[1\;37m[!]$esc[0m' '$esc[1\;32m^`{whoami}^'@'^`{hostname}^$esc[0m^' '^$esc[0m^$w^'; '^$esc^K
        }
    }
}

fn join-path {

    # process the first arg separately from the rest so that we can
    # cull or replace any forward slashes that are repeated.
    let (arg-1 = $*(1); args = $*(2 ...); result = $(1)) {

        # split the first arg by the path separator, and then count the
        # number of empty spaces which represent the path separators.
        let (index = 1; components = <={ %fsplit '/' $arg-1 }) {
            for (arg = $components) {
                if { !~ $arg '' } {
                    break
                }
                index=`{ expr $index + 1 }
            }

            # if our index was untouched, then there were no slashes. if we
            # consumed all the components, then they were all slashes and
            # we need to consolidate them to a single slash. otherwise, we
            # found some slashes and need to include it in our result.
            if {[ $index -le 1 ]} {
                result = ()
            } {[ $index -gt $#components ]} {
                result = ('/')
            } {
                result = ('')
            }

            # filter the rest of the components, and add them to our result.
            for (arg = $components( $index ... )) {
                if { !~ $arg '' } {
                    result = ( $result $arg )
                }
            }
        }

        # if our result is a slash and we have more work to do, then
        # empty it to ensure that it is prefixed with only one slash.
        if {~ $result '/' && [ $#args -gt 0 ]} {
            result = ('')
        }

        # filter the rest of the components and add them too.
        for (arg = $args) {
            for (item = <={ %fsplit '/' $arg }) {
                if { !~ $item '' } {
                    result = ( $result $item )
                }
            }
        }

        # now we can join our result with path separators and return it.
        return <={%flatten '/' $result}
    }
}

fn absolute-path path {
    let ( joined = <={ join-path $path } ) {
        match $joined (
            '/' { return '/' }
            *   { return '/' ^ `{realpath --canonicalize-missing --no-symlinks --relative-base=/ $joined} }
        )
    }
}

fn expand-path path {
    let ( user = `whoami; suffix = $path ) {
        match $path (
            ~   { return $home }
            ~/* { return <={ join-path $home <={~~ $path ~/*} } }
            ~*/ {
                components = <={ %fsplit '/' $path }
                user = <={~~ $components(1) ~*}
                suffix = <={~~ $path ~$user^*}
            }
            ~*/*    {
                components = <={ %fsplit '/' $path }
                user = <={~~ $components(1) ~*}
                suffix = <={ %flatten '/' ('' $components(2 ...)) }
            }
            ~*  {
                user = <={~~ $path ~*}
                suffix = ()
            }
            *   { return $path }
        )
        if {[ $#user -eq 0 ]} { return $path }

        entry = `` \n {getent passwd $user}
        if {[ $#entry -eq 0 ]} { throw error expand-path 'expand-path: ' ^ $path ^ ': No such file or directory' }

        row = <={%fsplit ':' $entry}
        return <={ %flatten '' ($row(6) $suffix)}
    }
}

fn resolve-path cwd path {

    # convert the current working directory to an absolute path. if it's not
    # the root path, then suffix it with a '/' to append the path parameter.
    let (wd = <={absolute-path $cwd}) {
        match $wd (
            / { base = '/' }
            * { base = $wd ^ '/' }
        )

        # now we can use the fixed base path to generate a full path for our
        # parameters. if it is absolute, then we can trust the result from
        # `realpath(1)`. if relative, though, the result needs the base path.
        let (fullpath = $base ^ $path) {
            match $path (
                (/*)    { rp = `{realpath --canonicalize-missing --no-symlinks --relative-base=$wd $fullpath} }
                *       { rp = $base ^ `{realpath --canonicalize-missing --no-symlinks --relative-base=$wd $fullpath} }
            )
        }

        # last thing to do is to trip the working directory from the real
        # path. if it is absolute or forced to be absolute and contains the
        # base, then strip it. if it is the same as the base, then return the
        # '.' symbol. otherwise, we return the forced absolute path untouched.
        let (forcedabsolute = '/' ^ $rp) {
            if {~ $rp /*} {
                return <={ ~~ $rp $base^* }
            } {~ $forcedabsolute^'/' $base} {
                return '.'
            } {~ $forcedabsolute $base^*} {
                return <={~~ $forcedabsolute $base^*}
            } {~ $forcedabsolute '/.'} {
                return <={~~ $forcedabsolute *.}
            } {
                return $forcedabsolute
            }
        }
    }
}

fn cd-absolute path {
    let (rp = <={ absolute-path $path }) {
        if {!access -d $path} {
            throw error cd-absolute 'cd-absolute: '^$path^': No such file or directory'
        }
        cd $rp
    }
}

let (old-directory = `pwd) {
    fn cd-preserve path {
        cwd = `pwd
        match $path (
            -   {
                cd-absolute $old-directory
                old-directory = $cwd
            }
            *   {
                let (rp = <={ expand-path $path }) {
                    cd-absolute $rp
                    old-directory = $cwd
                }
            }
        )
    }
}

let (working-directory-stack = (/etc /tmp)) {
    fn get-directory-stack {
        let (wd = `pwd) {
            match $wd (
                $home^* { wd = '~' ^ <={~~ $wd $home^*} }
            )
            let (current-directory-stack = ($wd $working-directory-stack)) {
                echo <={%flatten ' ' $current-directory-stack}
            }
        }
    }

    fn push-directory-stack directory {
        # get the current directory, and expand our directory
        # parameter to an absolute path.
        let (
            cwd = `pwd;
            expanded = <={expand-path $directory};
        ) {
            fp = <={absolute-path $expanded}

            # resolve the parameter path to one that is relative to
            # our home directory so we can add it to the stack.
            let (rp = <={resolve-path ~ $fp}) {
                match $rp (
                    /*      { target = $fp }
                    .       { target = '~' }
                    *       { target = '~/'^$rp }
                )
            }

            # now we can switch to the parameter directory, and then
            # update our stack with the previous working directory.
            cd-preserve $target
            working-directory-stack = ($cwd $working-directory-stack)

            # only thing left to do is to output the current directories.
            # we present the target working directory in its '~' form.
            match $target (
                $home^* { target = '~' ^ <={~~ $target $home^*} }
            )
            let (current-directory-stack = ($target $working-directory-stack)) {
                echo <={%flatten ' ' $current-directory-stack}
            }
        }
    }

    fn pop-directory-stack {
        if {[ $#working-directory-stack -lt 1 ]} {
            let (count = `{expr $#working-directory-stack + 1}) {
                throw error pop-directory-stack 'unable to pop from an empty directory stack ('^$count^' entry).'
            }
        }

        # start by popping the head of the directory stack, and
        # then updating the stack with the elements that are left.
        let (
            head = <={ expand-path $working-directory-stack(1) };
            rest = $working-directory-stack(2 ...);
        ) {
            working-directory-stack = $rest

            # now we can switch to the directory that we removed.
            cd-preserve $head

            # last thing to do is to output the current directory stack.
            # we include the target directory we popped in its '~' form.
            match $head (
                $home^* { head = '~' ^ <={~~ $head $home^*} }
            )
            let (current-directory-stack = ($head $working-directory-stack)) {
                echo <={%flatten ' ' $current-directory-stack}
            }
        }
    }

    fn rotate-directory-stack direction {
        if {[ $#working-directory-stack -lt 1 ] && [ $direction -ne 0 ]} {
            let (count = `{expr $#working-directory-stack + 1}) {
                throw error rotate-directory-stack 'unable to rotate directory stack containing '^$count^' entries.'
            }
        }

        # quick optimization for the number of possible rotations
        let (count-with-current-directory = `{expr $#working-directory-stack + 1}) {
            direction = `{ expr $direction % $count-with-current-directory }
        }

        # add the current working directory to our new directory stack.
        let (new-directory-stack = (`pwd $working-directory-stack)) {

            # now we can rotate the new stack with whatever the caller gave us.
            while {[ $direction -ne 0 ]} {
                if {[ $direction -gt 0 ]} {
                    let (
                        first = $new-directory-stack(1);
                        rest = $new-directory-stack(2 ...);
                    ) {
                        new-directory-stack = ( $rest $first )
                    }
                    direction = `{ expr $direction - 1 }

                } {[ $direction -lt 0 ]} {
                    let (
                        last = $new-directory-stack($#new-directory-stack);
                        head = $new-directory-stack(... `{expr $#new-directory-stack - 1});
                    ) {
                        new-directory-stack = ( $last $head )
                    }
                    direction = `{ expr $direction + 1 }
                }
            }

            # now we need to remove the head of the rotated stack, change
            # to its directory, and update the final stack with the rest.
            let (
                head = $new-directory-stack(1);
                rest = $new-directory-stack(2 ...);
            ) {
                working-directory-stack = $rest
                cd-preserve $head
            }
            echo <={%flatten ' ' $new-directory-stack}
        }
    }
}

# assign some aliases for the directory stack functions.
fn-dirs = @{ get-directory-stack $* }
fn-pushd = @{ push-directory-stack $* }
fn-popd = @{ pop-directory-stack $* }

# when we start, we should 'cd .' to set the colourful prompt
fn %prompt {
    cd .
    fn %prompt # now lose the prompt function
}
